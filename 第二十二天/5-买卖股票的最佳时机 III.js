// 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

// 输入：prices = [3,3,5,0,0,3,1,4]
// 输出：6
// 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
//      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

// 每一天结束之后，有可能处于以下五种状态之一：
// 没有买股也没有卖股。
// 买了第一支股，但是还没有卖出第一支股。
// 买了第一支股，并且卖出第一支股。
// 买了第一支股，并且卖出第一支股，买了第二支股，但是还没有卖出第二支股。
// 买了第一支股，并且卖出第一支股，买了第二支股，并且卖出第二支股。
// 我们可以遍历 prices 数组，模拟第 i 天的情况。计算出第 i 天五种情况利润的最大值。

// 对于第一种情况，利润始终为 0。

// 对于第二种情况，由于还没有盈利，只买进了某支股，为亏损状态。
// 此时，亏损的最小值是 prices[0] 至 prices[i] 的最小值，假设为 buy1。
// 可以看做，第二种情况利润的最大值为：-buy1。
// 状态转移方程为：
// buy1 = max(buy1, -prices[i]);

// 对于第三种情况，利润的计算需要在第二种情况的基础上再卖出一支股。
// 所以需要先计算第二种情况，再在遍历到 prices[i] 的时候，判断要不要卖出。
// 如果在以最小的亏损买入第一支股的情况下，卖出当前这支股所得利润最大，则卖出当前这支股。

// 状态转移方程为：
// sell1 = max(sell1, prices[i] + buy1);
// 注意这里是 prices[i] + buy1，不是 prices[i] - buy1，因为 buy1 是负值，代表利润。

// 对于第四种情况，不能直接买入，因为有可能第一支股还没卖出。
// 利润的计算需要在第三种情况的基础上再买入一支股。
// 所以需要先计算第三种情况，再在遍历到 prices[i] 的时候，判断要不要买入。
// 如果在卖出第一支股所得利润最大的情况下，买入当前这支股最终所得利润最大，则买入当前这支股。

// 状态转移方程为：
// buy2 = max(buy2, sell1 - prices[i]);
// 对于第五种情况，利润的计算需要在第四种情况的基础上再卖出一支股。
// 所以需要先计算第四种情况，再在遍历到 prices[i] 的时候，判断要不要卖出。
// 如果在卖出第一支股然后买入第二支股所得利润最大的情况下，卖出当前这支股所得利润最大，则卖出当前这支股。

// 状态转移方程为：
// sell2 = max(sell2, prices[i] + buy2);
// 最终的 sell2 就是我们要的答案。

const prices = [3, 3, 5, 0, 0, 3, 1, 4];
var maxProfit = function (prices) {
  const n = prices.length;
  let buy1 = -prices[0];
  let sell1 = 0;
  let buy2 = -prices[0];
  let sell2 = 0;

  for (let i = 1; i < n; i++) {
    buy1 = Math.max(buy1, -prices[i]);
    sell1 = Math.max(sell1, prices[i] + buy1);
    buy2 = Math.max(buy2, sell1 - prices[i]);
    sell2 = Math.max(sell2, prices[i] + buy2);
  }

  return sell2;
};

console.log(maxProfit(prices));
