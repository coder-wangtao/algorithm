// 题干的意思是：找出这个数组排序出的所有数中，刚好比当前数大的那个数
// 比如当前 nums = [1,2,3]。这个数是123，找出1，2，3这3个数字排序可能的所有数 [1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] ，排序后，比123大的那个数
// 也就是132
// 如果当前 nums = [3,2,1]。这就是1，2，3所有排序中最大的那个数，那么就返回1，2，3排序后所有数中最小的那个，也就是1，2，3 -> [1,2,3]

// const nums = [4, 5, 2, 6, 3, 1];
// [4, 5, 3, 6, 2, 1];
const nums = [4, 5, 2, 6, 3, 1];

var nextPermutation = function (nums) {
  const n = nums.length;
  // 从右往左遍历，找到第一个非降序的数
  // 1. [4,5,2,6,3,1]
  // 2. [3,2,1]】
  let l = -1;
  for (let i = n - 1; i >= 1; i--) {
    //l = 2
    if (nums[i - 1] < nums[i]) {
      l = i - 1;
      break;
    }
  }

  // 1. [4,5,2,6,3,1]: l=2
  // 2. [3,2,1]: l=-1
  if (l !== -1) {
    let r = -1;
    // 找到了之后，再从右往l+1遍历，找到第一个大于nums[l]的数，一定能找到
    // 1. [4,5,2,6,3,1]: r=4
    for (let i = n - 1; i > l; i--) {
      if (nums[i] > nums[l]) {
        r = i;
        break;
      }
    }
    // 交换l和r的数字
    // 1. [4,5,2,6,3,1] => [4,5,3,6,2,1]
    [nums[l], nums[r]] = [nums[r], nums[l]];
  }
  // 从l+1开始，后面的数字一定都是降序，改为升序
  // 降序改为升序，不需要快排、归并、堆排等方法，直接双指针，依次交换头尾数字即可
  // 1. [4,5,3,6,2,1], 从下标[l+1=3]开始从降序改为升序
  // 2. [3,2,1], 从下标[l+1=0]开始从降序改为升序
  let i = l + 1,
    j = n - 1;
  while (i < j) {
    [nums[i], nums[j]] = [nums[j], nums[i]];
    i++;
    j--;
  }
};
// 453126
nextPermutation(nums);
console.log(nums);
